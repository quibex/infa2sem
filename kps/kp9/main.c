#include <stdio.h>
#include <stdbool.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>
#include "borders_stack.h"

#define max_elem_data_size 1000
#define max_arr_elem_size 100

typedef struct
{
    int intg;
    char lit;
} key;

typedef struct
{
    key key;
    char data[max_elem_data_size];
} elem;

void print_elem(elem *el)
{
    printf("{ %d, %c}: %s\n", el->key.intg, el->key.lit, el->data);
}

void print_arr_elem(elem *arr, int arr_size)
{
    for (int i = 0; i < arr_size; i++)
    {
        printf("%d %c : %s\n", arr[i].key.intg, arr[i].key.lit, arr[i].data);
    }
}

int cmp(key a, key b)
{
    if (a.intg != b.intg)
    {
        return a.intg - b.intg;
    }
    return a.lit - b.lit;
}

elem calc_pivot(elem *arr, int i, int j)
{
    srand(time(NULL));       // инициализация генератора случайных чисел
    int random = rand() % 3; // генерируем случайное число от 0 до 2
    elem i_j_hoarult;
    switch (random)
    {
    case 0:
        i_j_hoarult = arr[i];
        break;
    case 1:
        i_j_hoarult = arr[j / 2];
        break;
    case 2:
        i_j_hoarult = arr[j];
        break;
    }
    return i_j_hoarult;
}

void swap(elem *arr, int i, int j)
{
    elem c = arr[i];
    arr[i] = arr[j];
    arr[j] = c;
}

borders hoar_partition(elem *arr, int l, int r, elem b)
{
    int i = l, j = r;
    do
    {
        while (cmp(arr[i].key, b.key) < 0)
            i++;
        while (cmp(arr[j].key, b.key) > 0)
            j--;
        if (i <= j)
        {
            swap(arr, i, j);
            i++;
            if (j > 0)
                j--;
        }
    } while (i <= j);
    borders i_j_hoar = {i, j};

    return i_j_hoar;
}

void hoar_sort(elem *arr, int size)
{
    borders_stack st;
    borders_stack_init(&st);

    // borders brdr = {0, size-1};
    // borders_stack_push(&st, brdr);
    borders_stack_push(&st, (borders){0, size - 1});

    while (!borders_stack_is_empty(&st))
    {
        borders cur_border = borders_stack_pop(&st);
        while (cur_border.R > cur_border.L)
        {

            elem pivot = calc_pivot(arr, cur_border.L, cur_border.R);

            borders i_j_hoar = hoar_partition(arr, cur_border.L, cur_border.R, pivot);

            if (i_j_hoar.L < cur_border.R)
            {
                borders r_half = {i_j_hoar.L, cur_border.R};
                borders_stack_push(&st, r_half);
            }
            cur_border.R = i_j_hoar.R;
        }
    }
}

void mix_arr_elem(elem *arr, int arr_size)
{
    srand(time(NULL)); // Инициализируем генератор случайных чисел
    for (int i = 0; i < arr_size; i++)
    {
        int j = rand() % arr_size;
        swap(arr, i, j);
    }
}

// bool read_kp9_elem(elem* arr){
//     int key1;
//     char key2;
//     char string[max_elem_data_size];
//     do {

//     } while ();
// }

elem *bin_search(elem *arr, int arr_size, key srch_elem_key)
{
    int i = 0, j = arr_size - 1;

    bool found = false;
    elem *found_el = NULL;
    while (i <= j)
    {
        int mid_idx = i + (j - i) / 2;

        if (cmp(arr[mid_idx].key, srch_elem_key) == 0)
        {
            found = true;
            found_el = &arr[mid_idx];
            j = mid_idx - 1;
        }

        if (cmp(arr[mid_idx].key, srch_elem_key) > 0)
            j = mid_idx - 1;

        if (cmp(arr[mid_idx].key, srch_elem_key) < 0)
            i = mid_idx + 1;
    }
    return found_el;
}

int main()
{
    elem arr[] = {
        {
            {1, 'd'},
            " 1.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢿⣿⣿⣿⣿⣿",
        },
        {
            {2, 'b'},
            " 2.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣤⣿⣿⣿⣿⣿",
        },
        {
            {2, 'z'},
            " 3.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⢿⠻⠟⠻⠟⠿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {3, 'f'},
            " 4.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠉⠀⠁⣀⣀⠐⠒⠂⠆⣀⣀⠉⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⢛⢉⡉⡉⢛⣛⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {4, 'f'},
            " 5.⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠃⢀⠐⣠⠷⠛⠉⠉⠙⠲⣄⠀⡄⠈⠻⠆⠀⡘⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢛⠍⣀⢹⢤⣃⠹⣧⢢⣂⢙⠷⢌⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {5, 'f'},
            " 6.⣿⣿⣿⣿⣿⣿⣿⣿⠋⠀⠐⣠⡞⠁⠀⠀⠀⠀⠀⣀⣟⣀⡀⢁⡤⢤⣆⠑⡄⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠘⠁⠜⣠⣫⢴⢺⡵⢥⣕⡯⢾⠦⢱⠳⡜⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {6, 'f'},
            " 7.⣿⣿⣿⣿⣿⣿⣿⠇⠀⡈⢀⡏⠀⠀⠀⣰⡶⠿⠏⠉⠉⠉⢹⡏⢀⣰⢿⡆⠰⠆⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡁⠎⡰⣸⠡⢶⣏⢿⣸⠯⣎⣰⠟⠚⡀⠠⡇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {7, 'f'},
            " 8.⣿⣿⣿⣿⣿⣿⡏⠀⢐⠀⣼⣇⠀⣠⠞⢁⡄⠒⠂⡉⡉⡉⠙⢿⣋⣁⡼⠃⠀⡅⢂⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⡇⢰⣵⠱⢛⣷⢾⢿⢞⣋⢗⠐⣨⣾⠇⡨⢱⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {8, 'f'},
            " 9.⣿⣿⣿⣿⣿⣿⡁⠐⡊⢠⠀⣨⠟⢁⡴⠁⡀⠒⠂⠂⣀⡰⢦⡀⢨⠡⠀⠐⢂⠐⡁⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⢠⠘⠊⣆⠟⣢⣋⡫⠛⠁⣐⣴⠟⣡⠆⠊⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {9, 'f'},
            "10.⣿⣿⣿⣿⣿⣿⠀⠐⡆⠀⠁⠀⢀⡞⠀⠂⠂⠢⠄⡂⢸⣆⢀⡟⠀⢀⡶⠶⢤⡀⠑⣈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡘⢶⣲⠈⣌⢀⣀⠀⠀⠈⢼⢐⠒⠐⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {10, 'f'},
            "11.⣿⣿⣿⣿⣿⣿⡅⠀⢳⡀⠀⠀⣈⣤⠶⠒⠲⣆⢀⣡⡀⠉⡉⠀⡀⢾⡀⢀⢠⡇⠐⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣌⡛⠶⠤⢭⠭⠭⠥⠾⣘⣩⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {12, 'f'},
            "12.⣿⣿⣿⣿⣿⣿⣗⡀⠠⢈⠁⣰⠏⠀⠀⠐⠀⠈⣿⠀⢸⠀⣀⣤⣄⠈⠓⠖⠉⣀⠂⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {12, 'f'},
            "13.⣿⣿⣿⣿⣿⣿⣿⣦⠀⠨⠀⢻⡀⠀⠀⠀⢀⣴⠏⠛⢧⡞⠁⢀⠈⢷⠀⠐⡀⠁⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {12, 'f'},
            "14.⣿⣿⣿⣿⣿⣿⣿⣿⣷⡐⢠⠀⠙⠲⠶⠖⠋⠁⠄⡀⠸⣇⠀⠀⣠⡟⠀⠂⣁⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣛⣙⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {12, 'f'},
            "15.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣌⠐⠒⠄⣀⠁⠉⠄⠡⠄⠈⢙⠛⠁⢀⢤⣺⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢡⠈⠿⢿⣿⣿⣿⣿⣿⣿",
        },
        {
            {12, 'f'},
            "16.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣄⣈⢉⡁⣁⢉⡁⣤⣴⣮⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⣛⡛⡛⠘⠀⠡⠩⠿⠝⢻⣿⣿⣿",
        },
        {
            {12, 'f'},
            "17.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣦⡄⢐⠀⢀⡀⠄⠺⢿⣿⣿⣿⣿",
        },
        {
            {17, 'f'},
            "18.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢠⠔⢠⣴⣄⣨⣔⠄⣿⣿⣿⣿",
        },
        {
            {18, 'f'},
            "19.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣧⣴⣾⣿⣿⣿⣿⣿⣶⣿⣿⣿⣿",
        },
        {
            {19, 'f'},
            "20.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {20, 'f'},
            "21.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {21, 'f'},
            "22.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢿⢟⣛⢛⣛⣛⣛⠛⡻⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {22, 'f'},
            "23.⣿⣿⣯⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⢿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢡⡾⠝⡈⠅⢈⢀⡉⢉⡛⣷⡚⡑⠬⠻⢿⠿⢿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {23, 'f'},
            "24.⣿⣿⣿⣿⣿⣿⣿⣿⢿⡋⠔⠈⣉⠽⢯⠽⢏⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢋⡴⢠⠆⠁⣀⠔⢈⠁⠆⠑⠀⠉⠡⠠⠘⠸⠀⠐⠈⠀⠤⠄⠄⢄⠠⠪⣙⠻⢿⣿⣿⣿⣿⣿",
        },
        {
            {24, 'f'},
            "25.⣿⣿⣿⣿⣿⣿⡟⢀⠌⠠⣱⠴⠨⠲⢹⠀⠢⢻⣾⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠘⠠⠀⢄⠂⠄⠀⠀⠐⢐⢨⢀⡐⠠⣐⠐⡀⠦⢰⡰⣶⣿⣿⣿⣷⣶⣤⡠⡄⢰⢹⣿⣿⣿⣿",
        },
        {
            {25, 'f'},
            "26.⣿⣿⣿⣿⣿⣿⠇⠀⠀⠘⡡⠐⢀⢠⢞⠄⠀⠀⠹⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⢋⢀⠁⠀⠀⠀⢀⢀⣐⢼⣀⢆⡸⡄⢆⢑⠅⠸⢑⠰⢸⠃⢿⣿⣿⣿⣿⣿⣿⣿⡇⢐⠘⣿⣿⣿⣿",
        },
        {
            {26, 'f'},
            "27.⣿⣿⣿⣿⣿⣯⢀⠀⠈⢠⠋⠠⢱⢢⢠⠀⠂⠀⢠⠐⢸⣿⣿⣿⣿⣿⣿⣿⠿⡛⢯⢩⠀⢠⠀⢀⠘⢠⠀⠠⠃⣠⢲⡏⡮⠧⠴⣌⠳⣘⠈⠕⢀⢅⢊⡦⠈⢼⢸⣿⣿⣿⣿⣿⣿⣿⠃⠾⢀⣿⣿⣿⣿",
        },
        {
            {27, 'f'},
            "28.⣿⣿⣿⣿⣿⣿⠀⠐⠀⢀⠘⠬⠢⣱⠈⠠⠀⠀⡈⢀⣿⣿⣿⣿⣿⣿⣿⣿⢟⠉⢀⠤⢐⣴⣶⣷⣟⢸⢠⢀⠦⣱⡟⢖⠔⠣⢘⢚⢡⠐⠲⡰⡴⣡⠋⠐⡀⢸⣻⣿⣿⣿⣿⠿⡟⢅⢀⣼⣿⣿⣿⣿⣿",
        },
        {
            {28, 'f'},
            "29.⣿⣿⣿⣿⣿⣿⣷⠀⢠⢲⡠⠀⢉⡘⠠⠔⠰⢠⡾⣽⣿⣿⣿⣿⣿⣿⣿⢰⢋⢐⣥⣾⡿⣿⣽⣿⣿⡄⠈⡈⠙⠓⠱⠐⠲⠣⡅⠎⠲⠘⢈⢰⠈⣘⠈⠘⠱⠘⠸⠿⠋⠡⠒⢐⣨⣾⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {29, 'f'},
            "30.⣫⡉⣿⣿⣿⣿⣿⣷⣆⣨⣘⣃⠃⢠⣭⢈⡼⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⠸⢸⢿⣷⣿⣿⣿⣿⣿⣧⠰⢤⠓⡙⠙⠻⠮⢱⣘⣐⠉⢊⠥⠴⠉⠁⠐⠀⠐⣐⣀⣤⣤⣦⣽⣤⣽⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {30, 'f'},
            "31.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣯⣽⣽⣿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡔⠀⢈⠙⠛⠻⠛⠿⠿⠿⠎⡙⢚⡂⣠⠰⠺⠊⠈⠀⢐⡉⠑⢀⠀⢀⠀⠴⠡⢃⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣛⠻",
        },
        {
            {31, 'f'},
            "32.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣤⠬⢀⠈⠨⢤⣤⣡⠠⡄⡀⠀⡐⢐⡀⠀⣀⣐⣀⠠⠴⣋⠄⠯⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣯",
        },
        {
            {32, 'f'},
            "33.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣿⣋⣡⣒⣚⣸⣽⣥⣶⣦⣀⣀⠒⠞⠲⠒⠶⢌⣓⣨⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {33, 'f'},
            "34.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {34, 'f'},
            "35.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {35, 'a'},
            "36.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {36, 'f'},
            "37.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢛⣵⢹⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {37, 'f'},
            "38.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢟⢔⢁⠜⡸⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {38, 'f'},
            "39.⣿⣿⣿⣿⣿⣿⡿⠟⠛⠙⢉⣙⠛⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣏⠩⠩⠭⠭⠑⠙⠐⠂⡂⢠⣿⣿⣿⣿⣿⣿⣿",
        },
        {
            {39, 'f'},
            "40.⣿⣿⣿⣿⡟⣩⠤⠀⠁⢠⡈⠉⣿⣶⣤⣽⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣿⣿⣮⢠⡬⠂⠐⠀⠙⢠⡁⠌⠙⢿⣿⣿⣿⣿",
        },
        {
            {40, 'f'},
            "41.⣿⣿⣿⠏⣴⠋⠀⠀⣤⣸⢕⠂⠀⣴⢮⣙⢷⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣼⣿⣿⣿⣿⣿⡾⣟⣿⣻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢋⣐⣱⠤⢲⣺⢀⣰⣾⣶⣴⣾⣿⣿⣿⣿",
        },
        {{41, 'h'}, "42.⣿⣿⣿⠰⡇⢰⣤⡄⠉⠑⡡⠞⣶⣉⢶⠌⢁⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢟⣋⢲⣱⣸⣤⣿⢻⡜⣙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣨⣶⣿⣿⣀⢻⡄⣿⣿⣿⣿⣿⣿⣿⣿⣿"},
        {{42, 'h'}, "43.⣿⣿⣿⠈⣛⠈⠉⠴⢀⠘⡓⢞⣩⢟⢈⢰⢟⡔⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⠯⢦⡿⣏⡷⣿⢿⣾⢻⡝⡷⠿⠾⠹⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣁⣿⣿⣿⣿⣿⣿⣿⣿⣿"},
        {{43, 'h'}, "44.⣿⣿⣿⣦⣷⠋⣈⣁⣵⣊⢲⢛⡱⠀⣠⠔⣛⣹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⡿⢦⢂⡿⣱⣏⣞⡥⡏⠄⣩⣜⠊⠉⠽⠟⣈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿"},
        {{44, 'h'}, "45.⣿⣿⣿⣿⣆⢛⣉⣙⢘⣂⣭⠔⠐⣑⣠⠾⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣹⡎⣾⢱⢷⡎⣿⢱⡎⣯⡻⣳⠎⢔⢮⢟⢣⡸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿"},
        {{45, 'h'}, "46.⣿⣿⣿⣿⣿⣷⣭⣛⠿⡷⣶⠿⡟⣯⣭⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣟⣮⡜⣫⢞⢾⣡⢷⠽⢿⠞⢐⣲⢈⢮⣾⢃⣷⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿"},
        {{46, 'h'}, "47.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣿⣷⣻⢙⠪⢷⡿⢬⣕⡁⣮⣿⠇⢠⢸⢟⣾⣿⢸⣿⣿⣿⣿⣯⠉⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿"},
        {{47, 'h'}, "48.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⢨⣜⢸⣮⠺⠌⢥⣼⡟⢱⣼⣜⢨⡾⢯⢃⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿"},
        {{48, 'h'}, "49.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⡿⣮⣍⠙⠰⢈⣟⠝⣴⣿⢉⣔⣯⣿⢹⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿"},
        {{49, 'h'}, "50.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣏⣠⡀⣌⢩⣜⠯⠷⠾⣙⣨⣴⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿"},
        {{50, 'h'}, "51.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣷⣤⣵⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿"},
        {{51, 'h'}, "52.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿"},
        {{52, 'h'}, "53.⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿"}};
    int arr_size = sizeof(arr) / sizeof(elem);

    mix_arr_elem(arr, arr_size);

    printf("Неотсортированный вид:\n");
    print_arr_elem(arr, arr_size);

    hoar_sort(arr, arr_size);

    printf("Oтсортированный вид:\n");
    print_arr_elem(arr, arr_size);

    key srch_elem_key;
    while (1)
    {

        printf("Введите ключ искомого элмента(example: \"int char\"): ");

        int c = getchar();
        if (c == EOF)
        {
            putchar('\n');
            break;
        }
        ungetc(c, stdin);

        int res_scan = scanf("%d %c", &srch_elem_key.intg, &srch_elem_key.lit);
        fflush(stdin);
        while (getchar() != '\n')
            ;
        if (res_scan != 2)
        {
            printf("Ключ введена неправильно\nCперва числовой потом литерный ключ\n");
            continue;
        }
        elem *srch_elem = bin_search(arr, arr_size, srch_elem_key);
        if (srch_elem == NULL)
            printf("Элемент с таким ключом не найден: %d %c\n", srch_elem_key.intg, srch_elem_key.lit);
        else
            printf("{%d %c}: %s\n", srch_elem->key.intg, srch_elem->key.lit, srch_elem->data);
    }

    return 0;
}